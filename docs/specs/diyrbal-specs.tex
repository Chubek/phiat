\DocumentMetadata{}
\documentclass[a4paper,12pt]{article}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{grammar}
\usepackage[
	style=authoryear,
	backend=biber,
	sorting=nyt,
	maxbibnames=99]{biblatex}

\addbibresource{references.bib}

\newcommand{\nm}{Diyrbal\xspace}
\newcommand{\gcmeth}{Mark\&Compact\xspace}

\newcommand{\citework}[1]{\parencite{#1}}

\begin{document}

\section{General description \& features}

\subsection{\nm: A short introduction}

\nm is a general-purpose, extensible, type-safe and statically-typed imperative Wirthian-esque scripting/programming language with stellar support for multi-paradigm programming (functional and object-oriented). It is both AoT'd\footnote{Ahead-of-time compilation} and JIT'd\footnote{Just-in-time compilation}.

Furthermore, \nm uses constraint-based type inference (a feature of functional languages, and more so, Rust) to allow user to forgo specification of types during programming.

After writing your scripts and programs, you specify whether you wish for your program to be interpreted on-the-go, or compiled to a process image, which is later read by a VM. The on-the-go interpretation also relies on a VM, but the set of opcodes used for interpretation, and compilation, are different.

\nm ships with a runtime to execute the process images. The users can download, and install the runtime only. You may have noticed a lot of similarities with Java now. In a way, \nm is a hybrid of Java, and the less byzantine scripting languages of Unix (Perl, Python, Ruby).

Both the VMs use \gcmeth method of garbage collection. % TODO: add more info on GC

In the following sections, we'll explain the features yieled by this implementation of \nm.

\subsection{Algebraic effects}

\nm tries to make coding easy, but more so, \textit{correct}. Algebraic effects, which came around at the beginning of the 2010s, hold the key to giving a language ``correct'' side-effect semantics, without relying much on the obliqueness of monads, or at the other end of the spectrum, ignroing side-effect semantics altogether.

Algebraic effects are made of \textbf{effects} and their \textbf{handlers}. With an effect, you specify \textit{what to expect}; with a handler, you specify \textit{how to react to those expectations}.

These systems are rife with potential for implementing I/O, state manipipulation, exception handling, non-determinism and concurrency. As such, I chose to wrap all the semantics of side-effects into my own Algebraic effect system, as specified by the operational semantics of \nm, specified later at \cref{}.

Of course, the system is wrapped in layers of intrinsic syntactic sugar. Otherwise, it would have been very difficult for the user to achieve simple tasks, such as assignment or printing to STDOUT. The algebraic effects for these intrinsic operations are handled behind the scene, and these are zero-cost abstractions: they do not affect the runtime. How this is done is discussed at \cref{}.

We will delve further into the Algebraic effect/handler system in \cref{}.

\subsection{Static vs. dynamic constructs}

When it comes to static vs. dynamic, \nm supports \textit{both}:

\begin{enumerate}
	\item Static records (product types) and dynamic records (``bundles'');
	\item Static enumerations (sum types) and dynamic enumerations (``polymorphic variants'');
	\item Static functions (``subroutines'') and dynamic functions s(named closures);
	\item Static arrays (baked into process image) and dynamic arrays;
	\item Static methods and dynamic methods (class fields that are closures);
	\item Static hashtables (look-up tables) and dynamic hashtables;
\end{enumerate}

As we see later, dynamic constructs are \textit{reflectable} and \textit{introspectable}. But static constructs are only the latter. 

During optimization (see \cref{}), some closures are \textit{lifted}, making them pragmatically equivocal to a subroutine. The compiles senses when it is appropriate to lift a closure, it won't do so without regards to dynamicity of the closure. All these constructs are discussed at length in a later section of this document.

\subsection{\gcmeth garbage collection}

As we discussed earlier, \nm is both an scripting, an a programming language. Thusly, for the scripting part of the deal, we need a robust, managed memory model. I chose the \gcmeth method of garbage collection for this endeavor.

Due to \textit{non-restrict} nature of \nm, \citework{} had a strong influence in choosing \gcmeth.

\notebox{This implementation of \nm has been thoroughly checked with both Address Sanitizer and Valgrind for possible memory leaks, on several test scripts.}

\subsection{C API and FFI}

\nm yields a fully-featured C API, that ties into its FFI\footnote{Foreign Function Interface} with C.


% TODO: discuss more features

\section{The grammar \& syntax for \nm}

\subsection{Philosophy behind the syntax}

My motto is, a language must be \textit{pretty} if one wishes for it to take off! 'Tis true that, if your syntax is decoupled from your semantics and pragmatics, then, you could install any syntax at the front-end of your compiler. But that leads to some weirdness. A syntax that is \textit{truly} decoupled from the semantics drives the designer to some unforseen implications, and complications thereof, ramifications of which will cause the userbase to wish they did not invest the time and effort in learning it.

Take for example, Java vs. Python. There's many languages riding on the hind legs of Java platform and JVM. There's not that many for Python, though. That is because the VM for Python is strongly coupled with its syntax. The same design choices made for Python have been made for \nm. Java's VM, on the other hand, is low-level, and with it, you can construct any language. I tried to follow principles of Java as well as Python's, making syntax of \nm coupled and at the same time, decoupled from its semantics and pragmatics.

\nm is arguably a \textit{Wirthian language}. It follows the same style as those of Pascal, Oberon and Modula-2. It does away with several restrictions (especially the enforcement of pre-declaration), and it also brings in several features for \nm's functional and OOP features.

Another influence for \nm are the ML family of languages (SML, OCaml, F#). The functional aspects of \nm closely follow that of ML's.

For the OOP aspects of \nm, it was not any of the hard-hitters like Java or C++ that influenced \nm, it was, rather, Common Lisp's Object Model\citework{}. 'Tis true that, \nm is not expressed symbolically via S-Expressions, but the syntax and semantics of OOP follows that of Common Lisp's. Another influence for OOP aspects of \nm is, of course, SmallTalk\citework{}.

We shall first give an informal overview of the syntax, and later, formalize the grammar in modern EBNF.

\subsection{An informal overview of \nm's syntax}

This section is divided into many sub-sections, each relating back to various lexical and syntactic constructs of \nm.

\subsubsection{Reserved keywords and type terms}

The following tables list all the reserved keywords, and type terms for \nm, in several categories.

\notebox{Due to its Wirthian origins, in \nm, keywords are case-insensitive.}

\begin{keywordlist}{Primitive type terms}
	\addkeyword{int8}{Signed 8-bit integer}
	\addkeyword{uint8}{Unsigned 8-bit integer}
	\addkeyword{int16}{Signed 16-bit integer}
	\addkeyword{uint16}{Unsigned 16-bit integer}
	\addkeyword{int32}{Signed 32-bit integer}
	\addkeyword{uint32}{Unsigned 32-bit integer}
	\addkeyword{int64}{Signed 64-bit integer}
	\addkeyword{uint64}{Unsigned 64-bit integer}
	\addkeyword{bignum}{Memory-resident bit-math integer}
	\addkeyword{float32}{IEEE754 single-precision float}
	\addkeyword{float64}{IEEE754 double-precision float}
	\addkeyword{real}{SIMD-powered maximal-precision float}
	\addkeyword{rational}{Fractional numbers}
	\addkeyword{complex}{Complex numbers}
	\addkeyword{uchar}{32-bit Unicode character}
	\addkeyword{wchar}{System-locale character}
	\addkeyowrd{char}{8-bit ASCII character}
\end{keywordlist}

\begin{keywordlist}{Composite type terms}
	\addkeyword{ustring}{32-bit Unicode string}
	\addkeyword{wstring}{System-locale string}
	\addkeyword{string}{ASCII string}
	\addkeyword{record}{Static product type}
	\addkeyword{variant}{Static sum and sum-of-product type}
	\addkeyword{bundle}{Encapsulated meta-object type}
	\addkeyword{inherits}{Inheritation term}
	\addkeyword{fun}{Closure disambiguator}
	\addkeyword{sub}{Static function (subroutine)}
	\addkeyword{meta}{Metaroutine (method)}
	\addkeyword{cfun}{C FFI function}
	\addkeyword{ctype}{C FFI primitive type}
	\addkeyword{cbundle}{C FFI struct type}
	\addkeyword{cvariant}{C FFI tagged union type}
\end{keywordlist}


\end{document}
