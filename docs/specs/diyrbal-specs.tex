\DocumentMetadata{}
\documentclass[a4paper,12pt]{article}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{grammar}
\usepackage[
	style=authoryear,
	backend=biber,
	sorting=nyt,
	maxbibnames=99]{biblatex}

\addbibresource{references.bib}

\newcommand{\nm}{Diyrbal\xspace}
\newcommand{\gcmeth}{Mark\&Compact\xspace}

\newcommand{\citework}[1]{\parencite{#1}}

\begin{document}

\section{General description \& features}

\subsection{Document outlook \& short introduction}

\nm is a higher-order, high-level, statically-typed, type-safe, multi-paradigm programming language with two backends (AoT'd VM with JiT, custom native code emitter) and an easy-to-grasp syntax. The following document specifies the language, and verifies part of the semantics for it.

% TODO: work in the intro

\subsection{Algebraic effects}

\nm tries to make coding easy, but more so, \textit{correct}. Algebraic effects, which came around at the beginning of the 2010s, hold the key to giving a language ``correct'' side-effect semantics, without relying much on the obliqueness of monads, or at the other end of the spectrum, ignroing side-effect semantics altogether.

Algebraic effects are made of \textbf{effects} and their \textbf{handlers}. With an effect, you specify \textit{what to expect}; with a handler, you specify \textit{how to react to those expectations}.

These systems are rife with potential for implementing I/O, state manipipulation, exception handling, non-determinism and concurrency. As such, I chose to wrap all the semantics of side-effects into my own Algebraic effect system, as specified by the operational semantics of \nm, specified later at \cref{}.

Of course, the system is wrapped in layers of intrinsic syntactic sugar. Otherwise, it would have been very difficult for the user to achieve simple tasks, such as assignment or printing to STDOUT. The algebraic effects for these intrinsic operations are handled behind the scene, and these are zero-cost abstractions: they do not affect the runtime. How this is done is discussed at \cref{}.

We will delve further into the Algebraic effect/handler system in \cref{}.

\subsection{Static vs. dynamic constructs}

When it comes to static vs. dynamic, \nm supports \textit{both}:

\begin{enumerate}
	\item Static records (product types) and dynamic records (``bundles'');
	\item Static enumerations (sum types) and dynamic enumerations (``polymorphic variants'');
	\item Static functions (``subroutines'') and dynamic functions s(named closures);
	\item Static arrays (baked into process image) and dynamic arrays;
	\item Static methods and dynamic methods (class fields that are closures);
	\item Static hashtables (look-up tables) and dynamic hashtables;
\end{enumerate}

As we see later, dynamic constructs are \textit{reflectable} and \textit{introspectable}. But static constructs are only the latter. 

During optimization (see \cref{}), some closures are \textit{lifted}, making them pragmatically equivocal to a subroutine. The compiles senses when it is appropriate to lift a closure, it won't do so without regards to dynamicity of the closure. All these constructs are discussed at length in a later section of this document.

\subsection{\gcmeth garbage collection}

As we discussed earlier, \nm is both an scripting, an a programming language. Thusly, for the scripting part of the deal, we need a robust, managed memory model. I chose the \gcmeth method of garbage collection for this endeavor.

Due to \textit{non-restrict} nature of \nm, \citework{} had a strong influence in choosing \gcmeth.

\notebox{This implementation of \nm has been thoroughly checked with both Address Sanitizer and Valgrind for possible memory leaks, on several test scripts.}

\subsection{C Interface and FFI}

\nm yields a fully-featured C Interface, that ties into its FFI\footnote{Foreign Function Interface} with C.

\subsection{The VM backend \& bytecode emitter}

% TODO

\subsection{The native-code backend \& emitter}

% TODO

% ---

% TODO: discuss more features

\section{The grammar \& syntax for \nm}

\subsection{Philosophy behind the syntax}

My motto is, a language must be \textit{pretty} if one wishes for it to take off! 'Tis true that, if your syntax is decoupled from your semantics and pragmatics, then, you could install any syntax at the front-end of your compiler. But that leads to some weirdness. A syntax that is \textit{truly} decoupled from the semantics drives the designer to some unforseen implications, and complications thereof, ramifications of which will cause the userbase to wish they did not invest the time and effort in learning it.

Take for example, Java vs. Python. There's many languages riding on the hind legs of Java platform and JVM. There's not that many for Python, though. That is because the VM for Python is strongly coupled with its syntax. The same design choices made for Python have been made for \nm. Java's VM, on the other hand, is low-level, and with it, you can construct any language. I tried to follow principles of Java as well as Python's, making syntax of \nm coupled and at the same time, decoupled from its semantics and pragmatics.

\nm is arguably a \textit{Wirthian language}. It follows the same style as those of Pascal, Oberon and Modula-2. It does away with several restrictions (especially the enforcement of pre-declaration), and it also brings in several features for \nm's functional and OOP features.

Another influence for \nm are the ML family of languages (SML, OCaml, F#). The functional aspects of \nm closely follow that of ML's.

For the OOP aspects of \nm, it was not any of the hard-hitters like Java or C++ that influenced \nm, it was, rather, Common Lisp's Object Model\citework{}. 'Tis true that, \nm is not expressed symbolically via S-Expressions, but the syntax and semantics of OOP follows that of Common Lisp's. Another influence for OOP aspects of \nm is, of course, SmallTalk\citework{}.

We shall first give an informal overview of the syntax, and later, formalize the grammar in modern EBNF.

\subsection{An informal overview of \nm's syntax}

This section is divided into many sub-sections, each relating back to various lexical and syntactic constructs of \nm.

\subsubsection{Reserved keywords and type terms}

The following tables list all the reserved keywords, and type terms for \nm, in several categories.

\notebox{Due to its Wirthian origins, in \nm, keywords are case-insensitive.}

\begin{keywordlist}{Primitive type terms}
	\addkeyword{int8}{Signed 8-bit integer}
	\addkeyword{uint8}{Unsigned 8-bit integer}
	\addkeyword{int16}{Signed 16-bit integer}
	\addkeyword{uint16}{Unsigned 16-bit integer}
	\addkeyword{int32}{Signed 32-bit integer}
	\addkeyword{uint32}{Unsigned 32-bit integer}
	\addkeyword{int64}{Signed 64-bit integer}
	\addkeyword{uint64}{Unsigned 64-bit integer}
	\addkeyword{bignum}{Memory-resident bit-math integer}
	\addkeyword{float32}{IEEE754 single-precision float}
	\addkeyword{float64}{IEEE754 double-precision float}
	\addkeyword{real}{SIMD-powered maximal-precision float}
	\addkeyword{rational}{Fractional numbers}
	\addkeyword{complex}{Complex numbers}
	\addkeyword{uchar}{32-bit Unicode character}
	\addkeyword{wchar}{System-locale character}
	\addkeyowrd{char}{8-bit ASCII character}
\end{keywordlist}

\begin{keywordlist}{Composite type terms}
	\addkeyword{ustring}{32-bit Unicode string}
	\addkeyword{wstring}{System-locale string}
	\addkeyword{string}{ASCII string}
	\addkeyword{record}{Static product type}
	\addkeyword{variant}{Static sum and sum-of-product type}
	\addkeyword{bundle}{Encapsulated meta-object type}
	\addkeyword{inherits}{Inheritation term}
	\addkeyword{fun}{Closure disambiguator}
	\addkeyword{sub}{Static function (subroutine)}
	\addkeyword{metafn}{Metaroutine (method)}
	\addkeyword{cfun}{C FFI function}
	\addkeyword{ctype}{C FFI primitive type}
	\addkeyword{cbundle}{C FFI struct type}
	\addkeyword{cvariant}{C FFI tagged union type}
\end{keywordlist}

\begin{keywordlist}{Type qualifier \& modifier keywords}
	\addkeyword{const}{Variable/actual parameter\footnote{An argument to ta function} \textit{can only} be modified through indirection}
	\addkeyword{immut}{Variable/actual parameter \textit{cannot} be modified \textbf{at all}}
	\addkeyword{local}{Variable \textit{shadows} variable of the same name from upper scopes}
	\addkeyword{global}{This modifier \textit{unshades} the previous shadowing by \textit{local}}
	\addkeyword{ref}{Actual parameter must be a pointer that \textit{cannot be null} (i.e. passed by reference)}
	\addkeyword{val}{Actual parameter must be \textit{passed by value} (i.e. evaluated before passing on as an argument)}
	\addkeyword{let}{Signals to the parser that, the RHS expression is an \textit{initializer}, see \cref{sec:assignment_operators}}
	\addkeyword{volatile}{Signals to the both backends not to optimize away this variable (mostly vital for the native-code backend)}
\end{keywordlist}

\begin{keywordlist}{Storage keywords}
	\addkeyword{static}{The variable is serialized, stored inside the process image}
	\addkeyword{new}{Box the result of expression on the heap}
	\addkeyword{delete}{Delete the boxed variable}
\end{keywordlist}

% TODO: more keyword categories

\subsection{Binary \& unary operators}

In \nm, assignment is an \textit{statement}, and not an expression. Therefore, I do not consider assignment to be a binary operator, the way it is in other C-dervied languages. However, \nm has a rich set of binary and unary operators, prefix and postfix. The following table shows them all.

Within a bundle definition, you can change how a bundle instance reacts to these operators using. See \cref{}.


\begin{oplist}{Unary operators}{unaryOp}
	\addop{+}{unaryPlus}{prefix}{Ineffective, unless specified by the metamethod}
	\addop{-}{unaryMinus}{prefix}{Two's complement negation of the operand expression}
	\addop{++}{unaryPreIncrement}{prefix}{Pre-increment of the operand}
	\addop{++}{unaryPostIncrement}{postfix}{Post-increment of the operand}
	\addop{\-\-}{unaryPreDecrement}{prefix}{Pre-decrement of the operand}
	\addop{\-\-}{unaryPostDecrement}{postfix}{Post-decrement of the operand}
	\addop{~}{unaryNot}{prefix}{Bitwise-not of the operand}
	\addop{!}{unaryNegate}{prefix}{Logical negation of the operand}
	\addop{[,]}{unaryBracketAccess}{postfix}{In aggregate types, accesses the nth item as specified by the enclosed operand}
	\addop{\{,\}}{unaryCurlyAccess}{postfix}{In tabular types, access the item as specified by the enclosed operand}
	\addop{(,)}{unaryCall}{postfix}{Treates comma-separated enclosed expressions as actual parameters, and calls the result of evaluation of the operand}
	\addop{@}{unaryAddressOf}{prefix}{Takes the address of operand}
	\addop{^}{unaryDereference}{prefix}{Dereferences the operand}
	\addop{^}{unaryPointerMark}{postfix}{Marks type term as a pointer}
	\addop{#}{prefix}{unarySizeof}{Returns size of the operand}
\end{oplist}

\begin{oplist}{Binary operators}
	\addop{+}{binaryAdd}{infix}{Adds operands}
	\addop{-}{binarySub}{infix}{Subtracts operands}
	\addop{*}{binaryTimes}{infix}{Multiples operands}
	\addop{/}{binaryDiv}{infix}{Divides operands}
	\addop{\%}{binaryMod}{infix}{Module of operands}
	\addop{^}{binaryXor}{infix}{Exclusive-or of operands}
	\addop{\|}{binaryOr}{infix}{Bitwise-or of operands}
	\addop{\&}{binaryAnd}{infix}{Bitwise-and of operands}
	\addop{<<}{BinaryShl}{infix}{Bitwise logical left shift}
	\addop{>>}{BinaryShr}{infix}{Bitwise logical right shift}
	\addop{>>>}{BinaryAsr}{infix}{Bitwise arithmetic right shift}
	\addop{\&\&}{binaryConjunct}{infix}{Logical conjunction}
	\addop{\|\|}{binaryDisjunct}{infix}{Logical disjunction}
	\addop{..}{binaryConcat}{infix}{Concatenate aggregate types}
	\addop{@}{binaryOffsetof}{infix}{Offset of field in composite type}
	\addop{.}{binaryMemberAccess}{infix}{Member access}
	\addop{:}{binaryMethodAccess}{infix}{Method access}
\end{oplist}

\begin{oplist}{Assignment operators}
	\addop{:=}{assnInit}{infix}{Initial assignment}
	\addop{<-}{assnRef}{infix}{Stores address of RHS in LHS}
	\addop{->}{assnDeref}{infix}{Stores value of LHS in RHS}
	\addop{<=}{assnCopy}{infix}{Copies result of RHS into LHS}
	\addop{<~}{assnBoxCopy}{infix}{Deep-copies result of RHS into LHS}
	\addop{~>}{assnUnbox}{infix}{Unboxes LHS into RHS}
	\addop{.=}{assnValue}{infix}{Regular assignment}
	\addop{<=>}{assnAlias}{infix}{Alias creation}
\end{oplist}

\begin{oplist}{Relational operators}
	\addop{=}{relEq}{infix}{Test whether LHS equals RHS}
	\addop{<>}{relNe}{infix}{Test whether LHS does \textit{not} equal RHS}
	\addop{>}{relGt}{infix}{Test whether LHS is greater than RHS}
	\addop{>=}{relGe}{infix}{Test whether LHS is greater than, or equal to RHS}
	\addop{<}{relLt}{infix}{Test whether LHS is lesser than RHS}
	\addop{<=}{relLe}{infix}{Test whether LHS is lesser than, or equal to, RHS}
\end{oplist}

\end{document}
