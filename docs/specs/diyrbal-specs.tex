\DocumentMetadata{}
\documentclass[a4paper,12pt]{article}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage[
	style=authoryear,
	backend=biber,
	sorting=nyt,
	maxbibnames=99]{biblatex}

\addbibresource{references.bib}

\newcommand{\nm}{Diyrbal\xspace}
\newcommand{\gcmeth}{Mark\&Compact\xspace}

\newcommand{\citework}[1]{\parencite{#1}}

\begin{document}

\section{General description \& features}

\subsection{\nm: A short introduction}

\nm is a general-purpose, extensible, type-safe and statically-typed imperative Wirthian-esque scripting/programming language with stellar support for multi-paradigm programming (functional and object-oriented). It is both AoT'd\footnote{Ahead-of-time compilation} and JIT'd\footnote{Just-in-time compilation}.

Furthermore, \nm uses constraint-based type inference (a feature of functional languages, and more so, Rust) to allow user to forgo specification of types during programming.

After writing your scripts and programs, you specify whether you wish for your program to be interpreted on-the-go, or compiled to a process image, which is later read by a VM. The on-the-go interpretation also relies on a VM, but the set of opcodes used for interpretation, and compilation, are different.

\nm ships with a runtime to execute the process images. The users can download, and install the runtime only. You may have noticed a lot of similarities with Java now. In a way, \nm is a hybrid of Java, and the less byzantine scripting languages of Unix (Perl, Python, Ruby).

Both the VMs use \gcmeth method of garbage collection. % TODO: add more info on GC

In the following sections, we'll explain the features yieled by this implementation of \nm.

\subsection{Algebraic effects}

\nm tries to make coding easy, but more so, \textit{correct}. Algebraic effects, which came around at the beginning of the 2010s, hold the key to giving a language ``correct'' side-effect semantics, without relying much on the obliqueness of monads, or at the other end of the spectrum, ignroing side-effect semantics altogether.

Algebraic effects are made of \textbf{effects} and their \textbf{handlers}. With an effect, you specify \textit{what to expect}; with a handler, you specify \textit{how to react to those expectations}.

These systems are rife with potential for implementing I/O, state manipipulation, exception handling, non-determinism and concurrency. As such, I chose to wrap all the semantics of side-effects into my own Algebraic effect system, as specified by the operational semantics of \nm, specified later at \cref{}.

Of course, the system is wrapped in layers of intrinsic syntactic sugar. Otherwise, it would have been very difficult for the user to achieve simple tasks, such as assignment or printing to STDOUT. The algebraic effects for these intrinsic operations are handled behind the scene, and these are zero-cost abstractions: they do not affect the runtime. How this is done is discussed at \cref{}.

We will delve further into the Algebraic effect/handler system in \cref{}.

\subsection{Static vs. dynamic constructs}

When it comes to static vs. dynamic, \nm supports \textit{both}:

\begin{enumerate}
	\item Static records (product types) and dynamic records (``bundles'');
	\item Static enumerations (sum types) and dynamic enumerations (``polymorphic variants'');
	\item Static functions (``subroutines'') and dynamic functions s(named closures);
	\item Static arrays (baked into process image) and dynamic arrays;
	\item Static methods and dynamic methods (class fields that are closures);
	\item Static hashtables (look-up tables) and dynamic hashtables;
\end{enumerate}

As we see later, dynamic constructs are \textit{reflectable} and \textit{introspectable}. But static constructs are only the latter. 

During optimization (see \cref{}), some closures are \textit{lifted}, making them pragmatically equivocal to a subroutine. The compiles senses when it is appropriate to lift a closure, it won't do so without regards to dynamicity of the closure. All these constructs are discussed at length in a later section of this document.

\subsection{\gcmeth garbage collection}

As we discussed earlier, \nm is both an scripting, an a programming language. Thusly, for the scripting part of the deal, we need a robust, managed memory model. I chose the \gcmeth method of garbage collection for this endeavor.

Due to \textit{non-restrict} nature of \nm, \citework{} had a strong influence in choosing \gcmeth.

\notebox{This implementation of \nm has been thoroughly checked with both Address Sanitizer and Valgrind for possible memory leaks, on several test scripts.}



\end{document}
